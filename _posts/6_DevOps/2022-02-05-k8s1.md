---
layout: "single"
title: "[Kubernetes] 1.쿠버네티스는 컨테이너 오케스트레이션 시스템이 아니다."
categories: [DevOps]
tags: [k8s, Kubernetes]
permalink: /k8s/1
---

# 쿠버네티스란 무엇인가

`컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커` 도서를 읽고 정리한 내용입니다.

## 쿠버네티스는 컨테이너 오케스트레이션 시스템이 아니다.

쿠버네티스는 단순한 오케스트레이션 시스템이 아니다. 쿠버네티스는 오케스트레이션의 필요성을 없애준다.
오케스트레이션의 기술적인 정의는 A→B→C 의 정의된 워크플로우를 수행하는 것이다.
반면에, 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다.

쿠버네티스는 **CRI(Container Runtime Interface)**를 통해서 대화한다.
그래서, 모든 도커 오케스트레이션들을 품을 수 있게 되었다.

- docker : **one** container on **one** host
- docker-compose : **multi** container on **one** host
- orchestration : **multi** container on **multi** host

## 물리 서버 → VM → Container

![container_evolution.svg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/125615c4-e86c-4bcf-b5bf-f1034b78b522/container_evolution.svg)

물리서버에서 유연함과 확장성을 위해 VM이 도입되었다.

VM은 운영체제를 포함한 격리된 하나의 머신이다.

컨테이너는 VM의 격리 속성을 완화했다.

컨테이너는 Host 인프라와 종속성을 끊었다. (이식성)

컨테이너는 VM과 마찬가지로 자체 fs, cpu 점유율, 메모리, 프로세스 공간이 있다.

컨테이너는 VM과 달리 OS 커널을 공유할 수 있다.

## 💜쿠버네티스는 컨테이너를 제공하지 않는다.

컨테이너 기술을 제공하는 플랫폼 중에는 **도커**🐳가 있다.

쿠버네티스는 지원하는 애플리케이션의 유형을 제한하지 않는다.

쿠버네티스는 소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않는다. 

- CI/CD 워크플로우는 별도로 구성한다.

쿠버네티스는 애플리케이션 레벨의 서비스를 제공하지 않는다.

- ex. 미들웨어(ex. 메시지 버스), 데이터 처리 프레임워크(ex. Spark), 데이터베이스(ex. MySQL), 캐시 또는 클러스터 스토리지 시스템(ex. Ceph)

쿠버네티스는 로깅, 모니터링, 경보 솔루션을 포함하지 않는다.

쿠버네티스는 설정 언어/시스템(ex.Jsonnet)을 제공하거나 요구하지 않는다.

쿠버네티스는 **포괄적인** 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공하거나 채택하지 않는다.

-----

# 그래서 쿠버네티스란 무엇인가

# 💜쿠버네티스는 컨테이너를 관리할 수 있다.

프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?

컨테이너화된 워크로드와 서비스를 관리하기 위한 **사용하기 쉽고, 강력하고, 견고하고, 확장 가능하며, 회복력**을 갖춘 오픈소스 플랫폼이다.

애플리케이션이 컨테이너에서 구동될 수 있다면, 쿠버네티스에서도 잘 동작할 것이다.

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 

애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다.

>참고로, k8s 는 “k”로 시작하고 “s”로 끝나며 그 사이에 “8”글자를 나타내는 kubernetes의 약어이다.

## 쿠버네티스의 기능

- 서비스 디스커버리와 로드 밸런싱
: 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포한다.
- 스토리지 오케스트레이션
: 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
- 자동화된 롤아웃과 롤백
: 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- 자동화된 빈 패킹(bin packing)
: 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시하면, 알맞은 쿠버네티스 클러스터 노드를 제공한다.
- 자동화된 복구(self-healing)
: 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- 시크릿과 구성 관리
: 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다.

-----

> Reference
- 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커 ([https://github.com/sysnet4admin/_Book_k8sInfra](https://github.com/sysnet4admin/_Book_k8sInfra))
- Kubernetes Docs ([https://kubernetes.io/ko/docs](https://kubernetes.io/ko/docs/home/))
